import 'dart:async';
import 'package:flutter_webrtc/flutter_webrtc.dart';
import '../models/call_models.dart';
import '../utils/logger_util.dart';
import 'signaling_client.dart';

/// Central manager for handling WebRTC calls (Audio-only)
class CallManager {
  final SignalingClient signalingClient;
  RTCPeerConnection? _peerConnection;
  MediaStream? _localStream;
  MediaStream? _remoteStream;
  String? _remoteUserId;
  CallStatus _callStatus = CallStatus.idle;

  final _callStateController = StreamController<CallState>.broadcast();
  Stream<CallState> get callState => _callStateController.stream;

  CallManager(this.signalingClient) {
    AppLogger.info("=== CallManager.initialize() called ===");
    AppLogger.debug("Setting up CallManager with SignalingClient");
    _initializeAudio();
    _setupSignalingCallbacks();
    AppLogger.info("‚úÖ CallManager initialized successfully");
  }

  void _setupSignalingCallbacks() {
    AppLogger.debug("=== CallManager._setupSignalingCallbacks() called ===");
    AppLogger.debug("Setting up ICE candidate callback from signaling client");
    
    signalingClient.onRemoteICECandidate = (RTCIceCandidate candidate) {
      AppLogger.info("üì© ICE candidate received from signaling");
      AppLogger.debug("ICE candidate: ${candidate.candidate}");
      AppLogger.debug("Peer connection state: ${_peerConnection != null ? 'exists' : 'null'}");
      
      if (_peerConnection != null) {
        AppLogger.debug("Adding ICE candidate to peer connection...");
        _peerConnection!.addCandidate(candidate);
        AppLogger.info("‚úÖ ICE candidate added to peer connection");
        AppLogger.debug("ICE candidate successfully processed");
      } else {
        AppLogger.warning("‚ö†Ô∏è Peer connection not ready for ICE candidate");
        AppLogger.debug("Peer connection is null, candidate will be dropped");
      }
    };
    
    AppLogger.debug("‚úÖ Signaling callbacks set up successfully");
  }

  void _initializeAudio() {
    AppLogger.debug("=== CallManager._initializeAudio() called ===");
    AppLogger.debug("Audio initialization will happen when creating peer connection");
    AppLogger.info("‚úÖ Audio initialization ready");
  }

  Future<RTCPeerConnection> _createPeerConnection() async {
    AppLogger.info("=== CallManager._createPeerConnection() called ===");
    AppLogger.debug("Creating WebRTC peer connection...");
    
    final configuration = {
      'iceServers': [
        {'urls': 'stun:stun.l.google.com:19302'},
      ],
    };
    AppLogger.debug("ICE servers configuration: $configuration");

    final constraints = {
      'mandatory': {},
      'optional': [
        {'DtlsSrtpKeyAgreement': true},
      ],
    };
    AppLogger.debug("Peer connection constraints: $constraints");

    AppLogger.debug("Calling createPeerConnection()...");
    final peer = await createPeerConnection(configuration, constraints);
    AppLogger.info("‚úÖ Peer connection created successfully");
    AppLogger.debug("Setting up peer connection event handlers...");

    // Set up ICE candidate handler
    peer.onIceCandidate = (RTCIceCandidate candidate) {
      AppLogger.info("üåê ICE candidate generated by peer connection");
      AppLogger.debug("ICE candidate: ${candidate.candidate}");
      AppLogger.debug("SDP MLine Index: ${candidate.sdpMLineIndex}, SDP Mid: ${candidate.sdpMid}");
      AppLogger.debug("Sending ICE candidate via signaling client...");
      signalingClient.sendICECandidate(candidate);
      AppLogger.debug("‚úÖ ICE candidate sent via signaling");
    };

    // Set up onAddTrack handler
    peer.onAddTrack = (MediaStream stream, MediaStreamTrack track) {
      AppLogger.info("üéß onAddTrack called - Remote audio track added");
      AppLogger.debug("Track ID: ${track.id}");
      AppLogger.debug("Track kind: ${track.kind}");
      AppLogger.debug("Stream ID: ${stream.id}");
      AppLogger.debug("Stream audio tracks: ${stream.getAudioTracks().length}");
      
      if (track.kind == 'audio') {
        AppLogger.debug("Processing audio track: ${track.id}");
        _remoteStream = stream;
        AppLogger.debug("Remote stream stored from onAddTrack event");
        
        // Enable the audio track to ensure audio plays
        AppLogger.debug("Enabling audio track: ${track.id}, current enabled: ${track.enabled}");
        track.enabled = true;
        AppLogger.debug("‚úÖ Audio track ${track.id} enabled");
        
        // Set default audio output to earpiece when call connects
        AppLogger.debug("Setting default audio output to earpiece...");
        _setAudioOutputRoute(false); // false = earpiece, true = speaker
        AppLogger.info("‚úÖ Audio output set to earpiece by default");
        
        AppLogger.debug("Updating call state to connected...");
        _updateCallState(CallStatus.connected);
        AppLogger.info("‚úÖ Remote track added via onAddTrack and call state updated");
      } else {
        AppLogger.debug("Track is not audio (kind: ${track.kind}), ignoring");
      }
    };

    // Set up track handler (unified plan - fallback method)
    peer.onTrack = (RTCTrackEvent event) {
      AppLogger.info("üéß onTrack called - Remote audio track added");
      AppLogger.debug("Streams count: ${event.streams.length}");
      
      if (event.streams.isNotEmpty) {
        AppLogger.debug("Processing first stream: ${event.streams[0].id}");
        _remoteStream = event.streams[0];
        AppLogger.debug("Remote stream stored from track event");
        
        // Enable all audio tracks to ensure audio plays
        final audioTracks = _remoteStream!.getAudioTracks();
        AppLogger.debug("Enabling ${audioTracks.length} remote audio track(s)...");
        for (var track in audioTracks) {
          AppLogger.debug("Enabling audio track: ${track.id}, current enabled: ${track.enabled}");
          track.enabled = true;
          AppLogger.debug("‚úÖ Audio track ${track.id} enabled");
        }
        
        // Set default audio output to earpiece when call connects
        AppLogger.debug("Setting default audio output to earpiece...");
        _setAudioOutputRoute(false); // false = earpiece, true = speaker
        AppLogger.info("‚úÖ Audio output set to earpiece by default");
        
        AppLogger.debug("Updating call state to connected...");
        _updateCallState(CallStatus.connected);
        AppLogger.info("‚úÖ Remote track added and call state updated");
      } else {
        AppLogger.warning("‚ö†Ô∏è Track event received but no streams available");
      }
    };

    // Set up ICE connection state handler
    peer.onIceConnectionState = (RTCIceConnectionState state) {
      AppLogger.info("üåê ICE connection state changed: $state");
      AppLogger.debug("Previous state: $_callStatus, New state: $state");
      
      switch (state) {
        case RTCIceConnectionState.RTCIceConnectionStateConnected:
          AppLogger.info("‚úÖ ICE connection established");
          AppLogger.debug("Updating call state to connected...");
          _updateCallState(CallStatus.connected);
          break;
        case RTCIceConnectionState.RTCIceConnectionStateCompleted:
          AppLogger.info("‚úÖ ICE connection completed");
          AppLogger.debug("Updating call state to connected...");
          _updateCallState(CallStatus.connected);
          break;
        case RTCIceConnectionState.RTCIceConnectionStateDisconnected:
          AppLogger.warning("‚ö†Ô∏è ICE connection disconnected");
          AppLogger.debug("Ending call due to disconnection...");
          endCall();
          break;
        case RTCIceConnectionState.RTCIceConnectionStateFailed:
          AppLogger.error("‚ùå ICE connection failed");
          AppLogger.debug("Ending call due to failure...");
          endCall();
          break;
        case RTCIceConnectionState.RTCIceConnectionStateClosed:
          AppLogger.info("üìû ICE connection closed");
          AppLogger.debug("Ending call due to closure...");
          endCall();
          break;
        default:
          AppLogger.debug("ICE connection state: $state (no action taken)");
          break;
      }
    };

    AppLogger.debug("‚úÖ All peer connection event handlers set up");
    AppLogger.info("‚úÖ Peer connection fully configured");
    return peer;
  }

  bool _isCallActive = false;

  /// Start call as caller
  Future<void> startCall(String toUserId) async {
    AppLogger.info("=== CallManager.startCall() called ===");
    AppLogger.debug("Target user ID: $toUserId");
    AppLogger.debug("Current call active state: $_isCallActive");
    AppLogger.debug("Current call status: $_callStatus");

    // Allow starting a new call if previous call has ended
    if (_isCallActive && _callStatus != CallStatus.ended && _callStatus != CallStatus.idle) {
      AppLogger.warning("‚ö†Ô∏è Call already active, ignoring startCall request");
      AppLogger.debug("Cannot start new call while existing call is active (status: $_callStatus)");
      return;
    }

    // Reset state if previous call ended
    if (_callStatus == CallStatus.ended || _callStatus == CallStatus.idle) {
      AppLogger.debug("Previous call ended, resetting state for new call...");
      _isCallActive = false;
      _remoteUserId = null;
      _peerConnection = null;
      _localStream = null;
      _remoteStream = null;
      AppLogger.debug("State reset for new call");
    }

    _remoteUserId = toUserId;
    _isCallActive = true;
    AppLogger.debug("Remote user ID set: $toUserId");
    AppLogger.debug("Call active flag set: true");

    try {
      // Get local audio stream
      AppLogger.info("üé§ Requesting local audio stream...");
      AppLogger.debug("Audio constraints: echoCancellation=true, noiseSuppression=true, autoGainControl=true");
      
      _localStream = await navigator.mediaDevices.getUserMedia({
        'audio': {
          'echoCancellation': true,
          'noiseSuppression': true,
          'autoGainControl': true,
        },
      });
      
      AppLogger.info("‚úÖ Local audio stream obtained");
      AppLogger.debug("Stream ID: ${_localStream?.id}");
      AppLogger.debug("Audio tracks: ${_localStream?.getAudioTracks().length ?? 0}");

      // Create peer connection
      AppLogger.info("üîó Creating peer connection...");
      _peerConnection = await _createPeerConnection();
      AppLogger.debug("Peer connection created: ${_peerConnection != null}");

      // Add local stream to peer connection
      AppLogger.debug("Adding local audio tracks to peer connection...");
      final tracksAdded = _localStream!.getTracks().length;
      _localStream!.getTracks().forEach((track) {
        AppLogger.debug("Adding track: ${track.id}, enabled: ${track.enabled}");
        _peerConnection!.addTrack(track, _localStream!);
      });
      AppLogger.info("‚úÖ Added $tracksAdded local audio track(s) to peer connection");

      AppLogger.debug("Updating call state to calling...");
      _updateCallState(CallStatus.calling);

      // Create offer
      AppLogger.info("üìù Creating SDP offer...");
      AppLogger.debug("Offer constraints: offerToReceiveAudio=true, offerToReceiveVideo=false");
      
      final offer = await _peerConnection!.createOffer({
        'offerToReceiveAudio': true,
        'offerToReceiveVideo': false,
      });
      
      AppLogger.info("‚úÖ SDP offer created");
      AppLogger.debug("Offer type: ${offer.type}");
      AppLogger.debug("SDP length: ${offer.sdp?.length ?? 0} characters");

      AppLogger.debug("Setting local description...");
      await _peerConnection!.setLocalDescription(offer);
      AppLogger.info("‚úÖ Local description set");

      // Send offer via signaling
      if (offer.sdp != null) {
        AppLogger.debug("Sending offer via signaling client...");
        signalingClient.sendOffer(offer.sdp!, toUserId);
        AppLogger.info("‚úÖ Offer sent via signaling");
      } else {
        AppLogger.error("‚ùå Cannot send offer: SDP is null");
      }

      AppLogger.info("‚úÖ Call initiated successfully!");
      AppLogger.debug("Call flow: Local stream -> Peer connection -> Offer created -> Offer sent");
    } catch (e, stackTrace) {
      AppLogger.error("‚ùå Error starting call", e, stackTrace);
      AppLogger.debug("Updating call state to failed...");
      _updateCallState(CallStatus.failed);
      AppLogger.debug("Call start failed, state updated");
    }
  }

  /// Answer incoming call
  Future<void> answerCall(String fromUserId, String offerSdp) async {
    AppLogger.info("=== CallManager.answerCall() called ===");
    AppLogger.debug("From user ID: $fromUserId");
    AppLogger.debug("Offer SDP length: ${offerSdp.length} characters");
    AppLogger.debug("Offer SDP preview: ${offerSdp.substring(0, offerSdp.length > 100 ? 100 : offerSdp.length)}...");
    AppLogger.debug("Current call active state: $_isCallActive");
    AppLogger.debug("Current call status: $_callStatus");

    // Allow answering if previous call has ended
    if (_isCallActive && _callStatus != CallStatus.ended && _callStatus != CallStatus.idle) {
      AppLogger.warning("‚ö†Ô∏è Call already active, cannot answer new call");
      AppLogger.debug("Current call status: $_callStatus");
      return;
    }

    // Reset state if previous call ended
    if (_callStatus == CallStatus.ended || _callStatus == CallStatus.idle) {
      AppLogger.debug("Previous call ended, resetting state for new call...");
      _isCallActive = false;
      _remoteUserId = null;
      _peerConnection = null;
      _localStream = null;
      _remoteStream = null;
      AppLogger.debug("State reset for new call");
    }

    _remoteUserId = fromUserId;
    _isCallActive = true;
    AppLogger.debug("Remote user ID set: $fromUserId");
    AppLogger.debug("Call active flag set: true");

    try {
      // Get local audio stream
      AppLogger.info("üé§ Requesting local audio stream for answer...");
      AppLogger.debug("Audio constraints: echoCancellation=true, noiseSuppression=true, autoGainControl=true");
      
      _localStream = await navigator.mediaDevices.getUserMedia({
        'audio': {
          'echoCancellation': true,
          'noiseSuppression': true,
          'autoGainControl': true,
        },
      });
      
      AppLogger.info("‚úÖ Local audio stream obtained");
      AppLogger.debug("Stream ID: ${_localStream?.id}");
      AppLogger.debug("Audio tracks: ${_localStream?.getAudioTracks().length ?? 0}");

      // Create peer connection
      AppLogger.info("üîó Creating peer connection for answer...");
      _peerConnection = await _createPeerConnection();
      AppLogger.debug("Peer connection created: ${_peerConnection != null}");

      // Add local stream to peer connection
      AppLogger.debug("Adding local audio tracks to peer connection...");
      final tracksAdded = _localStream!.getTracks().length;
      _localStream!.getTracks().forEach((track) {
        AppLogger.debug("Adding track: ${track.id}, enabled: ${track.enabled}");
        _peerConnection!.addTrack(track, _localStream!);
      });
      AppLogger.info("‚úÖ Added $tracksAdded local audio track(s) to peer connection");

      AppLogger.debug("Updating call state to answering...");
      _updateCallState(CallStatus.answering);

      // Set remote description (offer)
      AppLogger.info("üì• Setting remote description (offer)...");
      final offer = RTCSessionDescription(offerSdp, 'offer');
      AppLogger.debug("Offer type: ${offer.type}");
      await _peerConnection!.setRemoteDescription(offer);
      AppLogger.info("‚úÖ Remote description set successfully");

      // Create answer
      AppLogger.info("üìù Creating SDP answer...");
      AppLogger.debug("Answer constraints: offerToReceiveAudio=true, offerToReceiveVideo=false");
      
      final answer = await _peerConnection!.createAnswer({
        'offerToReceiveAudio': true,
        'offerToReceiveVideo': false,
      });
      
      AppLogger.info("‚úÖ SDP answer created");
      AppLogger.debug("Answer type: ${answer.type}");
      AppLogger.debug("SDP length: ${answer.sdp?.length ?? 0} characters");

      AppLogger.debug("Setting local description (answer)...");
      await _peerConnection!.setLocalDescription(answer);
      AppLogger.info("‚úÖ Local description (answer) set");

      // Send answer via signaling
      if (answer.sdp != null) {
        AppLogger.debug("Sending answer via signaling client...");
        signalingClient.sendAnswer(answer.sdp!, fromUserId);
        AppLogger.info("‚úÖ Answer sent via signaling");
        AppLogger.debug("Updating call state to connected...");
        _updateCallState(CallStatus.connected);
        AppLogger.info("‚úÖ Call answered successfully!");
      } else {
        AppLogger.error("‚ùå Cannot send answer: SDP is null");
      }
    } catch (e, stackTrace) {
      AppLogger.error("‚ùå Error answering call", e, stackTrace);
      AppLogger.debug("Updating call state to failed...");
      _updateCallState(CallStatus.failed);
      AppLogger.debug("Call answer failed, state updated");
    }
  }

  /// Handle remote answer
  Future<void> onRemoteAnswerReceived(String sdp) async {
    AppLogger.info("=== CallManager.onRemoteAnswerReceived() called ===");
    AppLogger.debug("Answer SDP length: ${sdp.length} characters");
    AppLogger.debug("Answer SDP preview: ${sdp.substring(0, sdp.length > 100 ? 100 : sdp.length)}...");
    AppLogger.debug("Peer connection state: ${_peerConnection != null ? 'exists' : 'null'}");
    
    try {
      AppLogger.debug("Creating RTCSessionDescription from answer SDP...");
      final answer = RTCSessionDescription(sdp, 'answer');
      AppLogger.debug("Answer type: ${answer.type}");
      
      AppLogger.info("üì• Setting remote description (answer)...");
      await _peerConnection!.setRemoteDescription(answer);
      
      AppLogger.info("‚úÖ Remote answer SDP set successfully");
      AppLogger.debug("Updating call state to connected...");
      _updateCallState(CallStatus.connected);
      AppLogger.info("‚úÖ Call connection established!");
    } catch (e, stackTrace) {
      AppLogger.error("‚ùå Failed to set remote answer", e, stackTrace);
      AppLogger.debug("Error occurred while setting remote description");
    }
  }

  /// End call and cleanup
  Future<void> endCall() async {
    AppLogger.info("=== CallManager.endCall() called ===");
    AppLogger.debug("Current call active state: $_isCallActive");
    AppLogger.debug("Remote user ID: $_remoteUserId");

    try {
      AppLogger.debug("Closing peer connection...");
      if (_peerConnection != null) {
        await _peerConnection?.close();
        AppLogger.debug("Peer connection closed");
      } else {
        AppLogger.debug("Peer connection was already null");
      }
      _peerConnection = null;
      AppLogger.info("‚úÖ Peer connection disposed");

      AppLogger.debug("Disposing local stream...");
      if (_localStream != null) {
        await _localStream?.dispose();
        AppLogger.debug("Local stream disposed");
      } else {
        AppLogger.debug("Local stream was already null");
      }
      _localStream = null;
      AppLogger.info("‚úÖ Local stream disposed");

      AppLogger.debug("Disposing remote stream...");
      if (_remoteStream != null) {
        await _remoteStream?.dispose();
        AppLogger.debug("Remote stream disposed");
      } else {
        AppLogger.debug("Remote stream was already null");
      }
      _remoteStream = null;
      AppLogger.info("‚úÖ Remote stream disposed");

      _remoteUserId = null;
      _isCallActive = false;
      AppLogger.debug("Remote user ID cleared, call active flag set to false");

      AppLogger.debug("Updating call state to ended...");
      _updateCallState(CallStatus.ended);
      
      // Reset to idle after a short delay to allow UI to update
      AppLogger.debug("Scheduling call state reset to idle in 500ms...");
      Future.delayed(const Duration(milliseconds: 500), () {
        AppLogger.debug("Resetting call state to idle after end...");
        _updateCallState(CallStatus.idle);
        AppLogger.info("‚úÖ Call state reset to idle - ready for new calls");
      });
      
      AppLogger.info("‚úÖ Call ended and cleaned up successfully");
    } catch (e, stackTrace) {
      AppLogger.error("‚ùå Error ending call", e, stackTrace);
      AppLogger.debug("Error occurred during call cleanup");
    }
  }

  /// Toggle mute/unmute
  void toggleMute() {
    AppLogger.info("=== CallManager.toggleMute() called ===");
    AppLogger.debug("Current mute state: ${isMuted()}");
    AppLogger.debug("Local stream state: ${_localStream != null ? 'exists' : 'null'}");
    
    final tracks = _localStream?.getAudioTracks();
    if (tracks == null || tracks.isEmpty) {
      AppLogger.warning("‚ö†Ô∏è Cannot toggle mute: no audio tracks available");
      return;
    }
    
    AppLogger.debug("Toggling ${tracks.length} audio track(s)...");
    for (final track in tracks) {
      final previousState = track.enabled;
      track.enabled = !track.enabled;
      AppLogger.debug("Track ${track.id}: $previousState -> ${track.enabled}");
    }
    
    final newMuteState = isMuted();
    AppLogger.info("‚úÖ Mute toggled: ${newMuteState ? 'MUTED' : 'UNMUTED'}");
  }

  /// Get mute state
  bool isMuted() {
    final tracks = _localStream?.getAudioTracks();
    if (tracks == null || tracks.isEmpty) {
      AppLogger.debug("No audio tracks available, returning unmuted");
      return false;
    }
    final muted = tracks.first.enabled == false;
    AppLogger.debug("Mute state: $muted");
    return muted;
  }

  /// Set audio output route (earpiece or speaker)
  void setAudioOutputRoute(bool speaker) {
    AppLogger.info("=== CallManager.setAudioOutputRoute() called ===");
    AppLogger.debug("Setting audio output to: ${speaker ? 'SPEAKER' : 'EARPIECE'}");
    
    _setAudioOutputRoute(speaker);
    
    AppLogger.info("‚úÖ Audio output route set to: ${speaker ? 'SPEAKER' : 'EARPIECE'}");
  }

  /// Internal method to set audio output route
  void _setAudioOutputRoute(bool speaker) {
    AppLogger.debug("=== CallManager._setAudioOutputRoute() called ===");
    AppLogger.debug("Speaker mode: $speaker");
    
    try {
      // Use flutter_webrtc's audio routing
      if (speaker) {
        AppLogger.debug("Setting audio output to SPEAKER...");
        // Set speaker mode
        Helper.setSpeakerphoneOn(true);
        AppLogger.debug("‚úÖ Speaker mode enabled");
      } else {
        AppLogger.debug("Setting audio output to EARPIECE...");
        // Set earpiece mode
        Helper.setSpeakerphoneOn(false);
        AppLogger.debug("‚úÖ Earpiece mode enabled");
      }
    } catch (e, stackTrace) {
      AppLogger.error("‚ùå Error setting audio output route", e, stackTrace);
      AppLogger.debug("Failed to change audio output route");
    }
  }

  void _updateCallState(CallStatus status) {
    AppLogger.debug("=== CallManager._updateCallState() called ===");
    AppLogger.debug("Previous status: $_callStatus, New status: $status");
    AppLogger.debug("Remote user ID: $_remoteUserId");
    
    final isCallActive = status != CallStatus.idle && status != CallStatus.ended;
    AppLogger.debug("Is call active: $isCallActive");
    
    final newState = CallState(
      isCallActive: isCallActive,
      callStatus: status,
      remoteUserId: _remoteUserId ?? "",
    );
    
    AppLogger.debug("Broadcasting new call state...");
    _callStateController.add(newState);
    _callStatus = status;
    AppLogger.info("‚úÖ Call state updated: $status");
  }

  void dispose() {
    AppLogger.info("=== CallManager.dispose() called ===");
    AppLogger.debug("Disposing CallManager and cleaning up resources...");
    
    endCall();
    
    AppLogger.debug("Closing call state stream controller...");
    _callStateController.close();
    
    AppLogger.info("‚úÖ CallManager disposed successfully");
  }
}

class CallState {
  final bool isCallActive;
  final CallStatus callStatus;
  final String remoteUserId;

  CallState({
    this.isCallActive = false,
    this.callStatus = CallStatus.idle,
    this.remoteUserId = "",
  });
}

